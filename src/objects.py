"""


"""


"""
LIBS
"""
import json
import os
import pandas as pd
from datetime import datetime


from functions import generate_uuid


"""
VARS
"""
budget_path = os.getenv("BUDGET_PATH", "../storage/test_budgets.csv")
account_path = os.getenv("ACCOUNT_PATH", "../storage/test_accounts.json")




"""
OBJECTS
"""
from dataclasses import dataclass, field

"""
### Account Dataclass ###
"""
@dataclass(frozen=False, order=False)
class Account:
    """
    Represents a bank account.

    Attributes:
        name (str): The name of the account.
        type (str): The type of the account (checking or savings).
        amount (float): The amount of money in the account.
        id (str): The unique identifier of the account.
        history (list): The transaction history of the account.
        _search_string (str): A string used for searching the account.

    Methods:
        __post_init__(): Initializes the account object.
        deposit(amount: float, transaction_id): Deposits money into the account.
        withdraw(amount: float, transaction_id): Withdraws money from the account.
        save(account_path: str = account_path): Saves the account to a JSON file without overwriting existing data.
    """
    # Name of the account
    name:str
    # Type of the account (checking or savings)
    type:str = "checking"
    # Amount of the account
    amount:float = 0.0

    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)
    # Search string
    _search_string:str = field(init=False, repr=False)


    def __post_init__(self) -> None:
        # Check if the type is an instance of available_account_types
        available_account_types = ("checking", "savings")
        if self.type not in available_account_types:
            raise TypeError(f"Invalid Account Type: {self.type}")
        # Check if the amount is a float and positive
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        

        self._search_string = f"Successfully created account ! \n" \
                              f"Name: {self.name} \n" \
                              f"Type: {self.type} \n" \
                              f"Amount: {self.amount}"
        
        print(self._search_string)


    def deposit(self, amount:float, transaction_id) -> None:
        """
        Deposit money into the account

        Args:
            amount (float): The amount of money to deposit.
            transaction_id: The ID of the transaction.

        Raises:
            ValueError: If the amount is negative.

        Returns:
            None
        """
        if amount < 0:
            raise ValueError(f"Invalid Deposit Amount: {amount}")
        self.amount += amount

        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "type": "deposit",
            "amount": amount,
        })

        print(f"Successfully deposited {amount} into account {self.name}. \n New amount: {self.amount}")


    def withdraw(self, amount:float, transaction_id) -> None:
        """
        Withdraw money from the account

        Args:
            amount (float): The amount of money to withdraw.
            transaction_id: The ID of the transaction.

        Raises:
            ValueError: If the amount is negative or exceeds the account balance.

        Returns:
            None
        """
        if amount < 0:
            raise ValueError(f"Invalid Withdraw Amount: {amount}")
        if amount > self.amount:
            raise ValueError(f"Insufficient funds to withdraw {amount} from account {self.name}.")
        
        
        self.amount -= amount

        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "type": "withdraw",
            "amount": amount,
        })

        print(f"Successfully withdrew {amount} from account {self.name}. \n New amount: {self.amount}")


    def save(self, account_path:str=account_path) -> None:
        """
        Save the account to a JSON file without overwriting existing data

        Args:
            account_path (str): The path to the JSON file.

        Returns:
            None
        """
        try:
            with open(account_path, "r") as file:
                data = json.load(file)
        except FileNotFoundError:
            data = {}

        # Update the data dictionary to include the new account
        data[self.name] = self.__dict__

        with open(account_path, "w") as file:
            json.dump(data, file, indent=4)

"""
### Budget Dataclass ###
"""
@dataclass(frozen=False, order=False)
class Budget:
    """
    Represents a budget in the banking app.

    Attributes:
        id (str): The unique identifier of the budget.
        name (str): The name of the budget.
        month (str): The month to which the budget is applicable.
        amount (float): The amount of the budget.
        history (list): The transaction history of the budget.
        _search_string (str): The search string used for filtering budgets.

    Methods:
        __post_init__(): Initializes the budget object after it has been created.
        add_amount(amount: float): Adds the specified amount to the budget.
        withdraw_amount(amount: float, transaction_id: int): Withdraws the specified amount from the budget.
        save(path: str="../storage/accounts.csv"): Saves the budget to a CSV file.

    """
    name: str
    month: str
    amount: float = 0.0


    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)
    # Search String
    _search_string: str = field(init=False, repr=False)

    def __post_init__(self) -> None:
        """
        Initializes the budget object after it has been created.

        Raises:
            ValueError: If the amount is negative.

        Returns:
            None

        """
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        print(f"Successfully created a budget:\nname: {self.name}\nmonth: {self.month}\namount: {self.amount}")


    def add_amount(self, amount: float) -> None:
        """
        Adds the specified amount to the budget.

        Parameters:
            amount (float): The amount to be added to the budget.

        Returns:
            None

        """
        self.amount += amount
        print(f"Added {amount} to budget {self.name}. New amount: {self.amount}")


    def withdraw_amount(self, amount: float, transaction_id: int) -> None:
        """
        Withdraws the specified amount from the budget.

        Parameters:
            amount (float): The amount to be withdrawn.
            transaction_id (int): The ID of the transaction.

        Raises:
            ValueError: If the specified amount is greater than the available amount in the budget.

        Returns:
            None

        """
        if amount > self.amount:
            raise ValueError(f"Not enough money in budget. Current amount: {self.amount}")

        self.amount -= amount
        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "amount": amount
        })
        print(f"Removed {amount} from budget {self.name}. New amount: {self.amount}")


    def save(self, budget_path: str=budget_path) -> None:
        """
        Saves the budget to a CSV file.

        Parameters:
            budget_path (str): The path to the CSV file. Default is "../storage/accounts.csv".

        Returns:
            None

        """
        budget_table = pd.read_csv(budget_path)

        # Check if a budget with the same name and month already exists
        if ((budget_table['name'] == self.name) & (budget_table['month'] == self.month)).any():
            raise ValueError(f"A budget with the name {self.name} and month {self.month} already exists.")


        new_budget_row = pd.Series(self.__dict__)
        budget_table = pd.concat([budget_table, new_budget_row.to_frame().T], ignore_index=True)
        budget_table.to_csv(budget_path, index=False)