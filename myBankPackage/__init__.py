__version__ = '0.1.1'



import uuid
import os
import json
import pandas as pd
from datetime import datetime
from dataclasses import dataclass, field


"""
PATHS
"""
# Path to the budget CSV file
budget_path = os.getenv("BUDGET_PATH", "./test_budgets.csv") 
# Path to the account JSON file
account_path = os.getenv("ACCOUNT_PATH", "./test_accounts.json")

"""
VALUE RESTRICTIONS
"""
available_account_types = ("checking", "savings")
available_transactions_types = ("debit", "credit", "transfert")

"""
COMMON FUNCTIONS
"""
def generate_uuid():
    """
    Generates a random UUID used for acocunt ID, transaction ID, etc.
    """
    return uuid.uuid4().hex



"""
ACCOUNT
"""
### Account Dataclass ###
@dataclass(frozen=False, order=False)
class Account:
    """
    Represents a bank account.

    Attributes:
        name (str): The name of the account.
        type (str): The type of the account (checking or savings).
        amount (float): The amount of money in the account.
        id (str): The unique identifier of the account.
        history (list): The transaction history of the account.
        _search_string (str): A string used for searching the account.

    Methods:
        __post_init__(): Initializes the account object.
        deposit(amount: float, transaction_id): Deposits money into the account.
        withdraw(amount: float, transaction_id): Withdraws money from the account.
        save(account_path: str = account_path): Saves the account to a JSON file without overwriting existing data.
    """
    # Name of the account
    name:str
    # Type of the account (checking or savings)
    type:str = "checking"
    # Amount of the account
    amount:float = 0.0

    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)


    def __post_init__(self) -> None:
        # Check if the type is an instance of available_account_types
        if self.type not in available_account_types:
            raise TypeError(f"Invalid Account Type: {self.type}")
        # Check if the amount is a float and positive
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        
        print(f"Successfully created account ! \n" \
                              f"Name: {self.name} \n" \
                              f"Type: {self.type} \n" \
                              f"Amount: {self.amount}")


    def deposit(self, amount:float, transaction_id) -> None:
        """
        Deposit money into the account

        Args:
            amount (float): The amount of money to deposit.
            transaction_id: The ID of the transaction.

        Raises:
            ValueError: If the amount is negative.

        Returns:
            None
        """
        if amount < 0:
            raise ValueError(f"Invalid Deposit Amount: {amount}")
        self.amount += amount

        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "type": "deposit",
            "amount": amount,
        })

        print(f"Successfully deposited {amount} into account {self.name}. \n New amount: {self.amount}")


    def withdraw(self, amount:float, transaction_id) -> None:
        """
        Withdraw money from the account

        Args:
            amount (float): The amount of money to withdraw.
            transaction_id: The ID of the transaction.

        Raises:
            ValueError: If the amount is negative or exceeds the account balance.

        Returns:
            None
        """
        if amount < 0:
            raise ValueError(f"Invalid Withdraw Amount: {amount}")
        if amount > self.amount:
            raise ValueError(f"Insufficient funds to withdraw {amount} from account {self.name}.")
        
        
        self.amount -= amount

        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "type": "withdraw",
            "amount": amount,
        })

        print(f"Successfully withdrew {amount} from account {self.name}. \n New amount: {self.amount}")


    def save(self, account_path:str=account_path) -> None:
        """
        Save the account to a JSON file without overwriting existing data

        Args:
            account_path (str): The path to the JSON file.

        Returns:
            None
        """
        try:
            with open(account_path, "r") as file:
                data = json.load(file)
        except FileNotFoundError:
            data = {}

        # Update the data dictionary to include the new account
        data[self.name] = self.__dict__

        with open(account_path, "w") as file:
            json.dump(data, file, indent=4)



"""
BUDGET
"""
### Budget Dataclass ###
@dataclass(frozen=False, order=False)
class Budget:
    """
    Represents a budget in the banking app.

    Attributes:
        id (str): The unique identifier of the budget.
        name (str): The name of the budget.
        month (str): The month to which the budget is applicable.
        amount (float): The amount of the budget.
        history (list): The transaction history of the budget.
        _search_string (str): The search string used for filtering budgets.

    Methods:
        __post_init__(): Initializes the budget object after it has been created.
        add_amount(amount: float): Adds the specified amount to the budget.
        withdraw_amount(amount: float, transaction_id: int): Withdraws the specified amount from the budget.
        save(path: str="../storage/accounts.csv"): Saves the budget to a CSV file.

    """
    name: str
    month: str
    amount: float = 0.0


    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)
    # Search String
    _search_string: str = field(init=False, repr=False)

    def __post_init__(self) -> None:
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        print(f"Successfully created a budget:\nname: {self.name}\nmonth: {self.month}\namount: {self.amount}")


    def add_amount(self, amount: float) -> None:
        """
        Adds the specified amount to the budget.

        Parameters:
            amount (float): The amount to be added to the budget.

        Returns:
            None

        """
        self.amount += amount
        print(f"Added {amount} to budget {self.name}. New amount: {self.amount}")


    def withdraw_amount(self, amount: float, transaction_id: int) -> None:
        """
        Withdraws the specified amount from the budget.

        Parameters:
            amount (float): The amount to be withdrawn.
            transaction_id (int): The ID of the transaction.

        Raises:
            ValueError: If the specified amount is greater than the available amount in the budget.

        Returns:
            None

        """
        if amount > self.amount:
            raise ValueError(f"Not enough money in budget. Current amount: {self.amount}")

        self.amount -= amount
        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "amount": amount
        })
        print(f"Removed {amount} from budget {self.name}. New amount: {self.amount}")


    def save(self, budget_path: str=budget_path) -> None:
        """
        Saves the budget to a CSV file.

        Parameters:
            budget_path (str): The path to the CSV file. Default is "../storage/accounts.csv".

        Returns:
            None

        """
        budget_table = pd.read_csv(budget_path)

        # Check if a budget with the same name and month already exists
        if ((budget_table['name'] == self.name) & (budget_table['month'] == self.month)).any():
            raise ValueError(f"A budget with the name {self.name} and month {self.month} already exists.")
        # Save the budget to the CSV file
        new_budget_row = pd.Series(self.__dict__)
        budget_table = pd.concat([budget_table, new_budget_row.to_frame().T], ignore_index=True)
        budget_table.to_csv(budget_path, index=False)



"""
TRANSACTION
"""
### Transaction Dataclass ###
@dataclass(frozen=False, order=False)
class Transaction:
    """

    """
    date: str = field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
    type:str = "debit"
    amount:float = 0.0
    origin_account:str = None
    destination_account:str = None
    budget:str = None

    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)


    def __post_init__(self) -> None:
        # Check if the type is an instance of available_account_types
        if self.type not in available_transactions_types:
            raise TypeError(f"Invalid Transaction Type: {self.type}")
        # Check if the amount is a float and positive
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        
        print(f"Successfully created Transaction ! \n" \
                              f"Date: {self.date} \n" \
                              f"Type: {self.type} \n" \
                              f"Amount: {self.amount} \n" \
                              f"Origin Account: {self.origin_account} \n" \
                              f"Destination Account: {self.destination_account} \n" \
                              f"Budget: {self.budget}")
        

    def apply_transaction(self) -> None:
        """
        
        """
        # Load origin_account

        # Load destination_account

        # load budget


        ## Apply transaction

        # Debit
        if self.type == "debit":
            pass

        # Credit
        elif self.type == "credit":
            pass

        # Transfert
        else:
            pass