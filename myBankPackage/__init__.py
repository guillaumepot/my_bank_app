__version__ = '0.1.1'



import uuid
import os
import pickle
import pandas as pd
from datetime import datetime
from dataclasses import dataclass, field


"""
VALUE RESTRICTIONS
"""
available_account_types = ("checking", "saving")
available_transactions_types = ("debit", "credit", "transfert")

"""
COMMON FUNCTIONS
"""
def generate_uuid():
    """
    Generates a random UUID used for acocunt ID, transaction ID, etc.
    """
    return uuid.uuid4().hex


def load_account(account_path:str, account_name:str=None):
    """
    Load an account from a file.

    Args:
        account_path (str): The path to the directory where the account files are stored.
        account_name (str): The name of the account to load.

    Returns:
        The loaded account object.

    Raises:
        ValueError: If the account name is not provided.
        FileNotFoundError: If the account file is not found.
    """
    if account_name is None:
        raise ValueError("Account name is required.")
    try:
        with open(f"{account_path}{account_name}.pkl", 'rb') as f:
            return pickle.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"Account {account_name} not found.")
    

def load_budget(budget_path:str, budget_name:str=None, budget_month:str=None):
    """
    Load a budget from a file.

    Args:
        budget_path (str): The path to the directory where the budget files are stored.
        budget_name (str): The name of the budget.
        budget_month (str): The month of the budget.

    Returns:
        The loaded budget.

    Raises:
        ValueError: If budget_name or budget_month is None.
        FileNotFoundError: If the budget file is not found.

    """
    if budget_name is None or budget_month is None:
        raise ValueError("Budget name and month are required.")
    try:
        with open(f"{budget_path}{budget_name}_{budget_month}.pkl", 'rb') as f:
            return pickle.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"Budget {budget_name} for month {budget_month} not found.")


def account_to_table(account_path):
    """
    Convert account data stored as pickle files in the given account_path directory into a pandas DataFrame.

    Parameters:
    account_path (str): The path to the directory containing the account data pickle files.

    Returns:
    pandas.DataFrame: A DataFrame containing the account data with columns: "name", "type", "amount", "id", "history".
    """
    account_table = pd.DataFrame(columns=["name", "type", "amount", "id", "history"])
    for file in os.listdir(account_path):
        if file.endswith(".pkl"):
            account_name = file.rsplit('.', 1)[0]
            account = load_account(account_path, account_name)
            account_table = pd.concat([account_table, pd.DataFrame([account.__dict__])], ignore_index=True)
    return account_table


def budget_to_table(budget_path):
    """
    Convert budget files in a given directory to a pandas DataFrame.

    Parameters:
    budget_path (str): The path to the directory containing the budget files.

    Returns:
    pandas.DataFrame: A DataFrame containing the budget information from the files.

    """
    budget_table = pd.DataFrame(columns=["name", "month", "amount", "id", "history"])
    for file in os.listdir(budget_path):
        if file.endswith(".pkl"):
            budget_name = file.rsplit('_', 1)[0]
            budget_month = file.rsplit('_', 1)[1].rsplit('.', 1)[0]
            budget = load_budget(budget_path, budget_name, budget_month)
            budget_table = pd.concat([budget_table, pd.DataFrame([budget.__dict__])], ignore_index=True)
    return budget_table


"""
ACCOUNT
"""
### Account Dataclass ###
@dataclass(frozen=False, order=False)
class Account:
    """

    """
    ### INIT ###
    # Name of the account
    name:str
    # Type of the account (checking or savings)
    type:str = "checking"
    # Amount of the account
    amount:float = 0.0

    ### NO INIT ###
    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)


    def __post_init__(self) -> None:
        # Check if the type is an instance of available_account_types
        if self.type not in available_account_types:
            raise TypeError(f"Invalid Account Type: {self.type}")
        # Check if the amount is a float and positive
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        


    def deposit(self, amount:float, transaction_id:str) -> None:
        """

        """
        if amount < 0:
            raise ValueError(f"Invalid Deposit Amount: {amount}")
        self.amount += amount

        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "type": "deposit",
            "amount": amount,
        })



    def withdraw(self, amount:float, transaction_id:str) -> None:
        """

        """
        if amount < 0:
            raise ValueError(f"Invalid Withdraw Amount: {amount}")
        if amount > self.amount:
            raise ValueError(f"Insufficient funds to withdraw {amount} from account {self.name}.")
        
        
        self.amount -= amount

        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "type": "withdraw",
            "amount": amount,
        })



    def save(self, account_path:str) -> None:
        """

        """
        # Check if account already exists
        if os.path.exists(f"{account_path}{self.name}.pkl"):
            print (f"Existing account {self.name} will be overwritten.")
        # Save the account
        with open(f"{account_path}{self.name}.pkl", 'wb') as f:
            pickle.dump(self, f)


"""
BUDGET
"""
### Budget Dataclass ###
@dataclass(frozen=False, order=False)
class Budget:
    """

    """
    ### INIT ###
    name: str
    month: str
    amount: float = 0.0


    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)
    # History
    history: list = field(init=False, default_factory=list)


    def __post_init__(self) -> None:
        if self.amount < 0:
            raise ValueError(f"Invalid Budget Amount (negative value): {self.amount}")





    def deposit(self, amount: float, transaction_id:str) -> None:
        """

        """
        self.amount += amount
        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "amount": amount
        })


    def withdraw(self, amount: float, transaction_id: str) -> None:
        """

        """
        if amount > self.amount:
            raise ValueError(f"Not enough money in budget. Current amount: {self.amount}")

        self.amount -= amount
        self.history.append({
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "transaction_id": transaction_id,
            "amount": amount
        })


    def save(self, budget_path: str) -> None:
        """

        """
        # Check if budget already exists
        if os.path.exists(f"{budget_path}{self.name}.pkl"):
            print (f"Existing budget {self.name} will be overwritten.")
        # Save the budget
        with open(f"{budget_path}{self.name}_{self.month}.pkl", 'wb') as f:
            pickle.dump(self, f)



"""
TRANSACTION
"""
### Transaction Dataclass ###
@dataclass(frozen=False, order=False)
class Transaction:
    """

    """
    ### NO INIT ###

    # Random ID is generated by a function
    id: str = field(init=False, default_factory=generate_uuid)


    ### INIT ###
    date: str = field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    type:str = "debit"
    amount:float = 0.0
    origin_account:str = None
    destination_account:str = None
    budget:str = None
    budget_month:str = None
    description:str=""



    def __post_init__(self) -> None:
        """

        """
        # Check if the type is an instance of available_account_types
        if self.type not in available_transactions_types:
            raise TypeError(f"Invalid Transaction Type: {self.type}")
        # Check if the amount is a float and positive
        if self.amount < 0:
            raise ValueError(f"Invalid Account Amount: {self.amount}")
        # If budget, check if it exists
        if (self.budget is not None) and (self.budget_month is None):
            raise ValueError("Budget month is required when budget is not None.")
        
        

    def save(self, transaction_path:str) -> None:
        """
        
        """
        if os.path.exists(transaction_path) and os.path.getsize(transaction_path) > 0:
            transaction_table = pd.read_csv(transaction_path)
        else:
            transaction_table = pd.DataFrame(columns=self.__dict__.keys())
            
        # Save the transaction to the CSV file
        new_transaction_row = pd.Series(self.__dict__)
        transaction_table = pd.concat([transaction_table, new_transaction_row.to_frame().T], ignore_index=True)
        transaction_table.to_csv(transaction_path, index=False)


    def apply(self, account_path:str, budget_path:str) -> None:
        """

        """
        ## Load accounts & budgets
        # Load origin_account
        if self.origin_account is not None:
            loaded_origin_account = load_account(account_path, self.origin_account)

        # Load destination_account
        if self.destination_account is not None:
            loaded_destination_account = load_account(account_path, self.destination_account)


        # Load budget
        if self.budget is not None:
            loaded_budget = load_budget(budget_path=budget_path, budget_name=self.budget, budget_month=self.budget_month)


        ## Apply transaction
        # Debit
        if self.type == "debit":
            # Update amount
            loaded_origin_account.withdraw(self.amount, self.id)
            # Save changes
            loaded_origin_account.save(account_path)
            # Update budget
            if self.budget is not None:
                loaded_budget.withdraw(self.amount, self.id)
                loaded_budget.save(budget_path)


        # Credit
        elif self.type == "credit":
            # Update amount
            loaded_destination_account.deposit(self.amount, self.id)
            # Save changes
            loaded_destination_account.save(account_path)
            # Update budget
            if self.budget is not None:
                loaded_budget.deposit(self.amount, self.id)
                loaded_budget.save(budget_path)

        # Transfert
        else:
            # Update origin account
            loaded_origin_account.withdraw(self.amount, self.id)
            loaded_origin_account.save(account_path)
            # Update destination account
            loaded_destination_account.deposit(self.amount, self.id)
            loaded_destination_account.save(account_path)